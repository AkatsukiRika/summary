# 实际遇到的问题

**Kotlin 的范型在编译时会被擦除。有关这种现象，会导致哪些在 Android 开发时容易遇到的问题，如何解决**

【容易遇到的问题】
1. JSON 反序列化拿不到具体类型：T 或 List<T> 在运行期只剩下 Object 或 List<?>，Retrofit 等转换器如果只传 T::class.java，会把 List<User> 当作 List<Map> 或直接失败
2. is / when 无法判断带实参的集合类型：if (x is List<String>) 会编译警告/被擦除，运行期只能判断是 List
3. Bundle / Intent / SavedStateHandle 里取值需要 Class：API 33+ 的 getParcelable(String, Class<T>) 需要传 Class，自己写的工具方法只有 T 会被擦除

【解决方案】
1. 给库传准确的类型：永远传 Type (TypedToken / Types.newParameterizedType)，不要只传 Class<T>
2. 能写 reified 就写：通用工具方法（如 startActivity<T>()、Bundle.parcelable<T>()、Response.parse<T>()）一律 inline + reified
3. 集合判断：只判外层 + 校验元素，不要写 is List<String>

--------------------------------------------------

**Activity 的四种启动模式**

1. standard (标准模式、默认): 每次启动都会创建一个新的 Activity 实例，新的实例总是加入当前任务栈的顶部，适用于绝大多数普通页面
2. singleTop (栈顶复用): 如果要启动的 Activity 已经在栈顶，就不会创建新实例，而是复用原有实例，否则创建新的实例并入栈。若复用，会触发 onNewIntent() 而不是 onCreate()，适用于避免重复打开同一个页面。
3. singleTask (栈内唯一): 整个任务栈中只会有一个该 Activity 实例。若已存在该实例，清除它上方的所有 Activity，调用它的 onNewIntent()。若不存在，新建实例并入当前或指定任务栈。适用于主页面、主页，希望全局唯一且清空返回栈。
4. singleInstance (单实例任务): 该 Activity 独占一个任务栈，且系统中只有一个实例，每次启动都复用该独立任务栈，不与其它 Activity 共栈。适用于特殊页面、跨应用调用时唯一显示。

--------------------------------------------------

**Android 中线程池相关方法有哪些参数，分别是做什么用的**

1. corePoolSize: 最小线程数
2. maximumPoolSize: 最大线程数
3. keepAliveTime: 非核心线程空闲多久被回收
4. unit: keepAliveTime 的单位
5. workQueue: 任务排队策略
6. threadFactory: 线程创建与命名
7. handler: 饱和时的应对策略

workQueue 常见类型：
1. 无界队列 (LinkedBlockingQueue): 默认容量 Integer.MAX_VALUE。任务会一直排队，不会创建非核心线程，可能导致 OOM。
2. 有界队列 (ArrayBlockingQueue): 固定长度，超过则创建新线程或拒绝。常用于控制并发。
3. 同步队列 (SynchronousQueue): 不存储任务，必须由线程直接接收。适用于 CachedThreadPool。
4. 优先级队列 (PriorityBlockingQueue): 根据任务优先级排序执行。

handler 拒绝策略：
1. AbortPolicy (默认): 抛出 RejectedExecutionException。
2. DiscardPolicy: 直接丢弃任务。
3. DiscardOldestPolicy: 丢弃队列头部最旧任务，重试当前任务。
4. CallerRunsPolicy: 由调用线程（提交任务的线程）自己执行任务，防止丢失但降低提交者性能。

--------------------------------------------------

**说说对 Handler 的理解**

Handler 是 Android 用来在特定线程（尤其是主线程）之间传递消息（Message）的工具，它解决了线程间通信的问题，让你在子线程执行耗时操作，再切回主线程更新 UI 成为可能。
Handler 的运行依赖于三个关键组件：MessageQueue (消息队列，保存待处理的 Message)、Looper (循环器，不断从 MessageQueue 取消息并派发)、Handler (负责发送消息与接收处理)。
Handler 与创建它的 Looper 所在线程绑定，适用于子线程更新 UI、延迟任务、循环任务等场景。

--------------------------------------------------

**一个自定义 View 的绘制流程分哪些阶段**

1. measure (测量阶段): 确定 View 的宽度和高度。
2. layout (布局阶段): 确定 View 的位置 (left, top, right, bottom)。
3. draw (绘制阶段): 真正把 View 内容绘制到屏幕（Canvas）上。
4. 刷新流程: 调用 invalidate() 或 requestLayout() 时会触发重绘，其中 invalidate() 只走 draw 阶段（不重新测量和布局），requestLayout() 重新走 measure + layout + draw 阶段。

--------------------------------------------------

**Android 触摸事件是如何传递的**

从顶层容器一路向下分发 (dispatch)，从 Activity 层 > Window / DecorView 层 > ViewGroup 层 > View 层，直到某个 View 消费 (consume) 事件为止。如果该 View 的 onTouchEvent() 返回了 false，事件会往上传递（冒泡）。

# AI 补充的问题

**HandlerThread 有什么作用**

HandlerThread 是一个自带 Looper 的专用后台线程，适合把一串需要按顺序、长期驻留且要求 Looper 的回调/消息放到同一条线程里处理（Camera、Audio、蓝牙、位置、ContentObserver 等）。启动后内部做了 Looper.prepare() + Looper.loop()，能获得一个长期存在、串行执行的后台消息循环。